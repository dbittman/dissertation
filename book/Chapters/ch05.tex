
\chapter{A Global Address Space}\label{ch:global}

\section{Memory Objects}


\unedit{

    \Twizzler organizes data into \emph{objects}, which may be persistent. Each object is
    identified by a unique 128~bit object ID (though larger IDs would be possible).
    %Organizing memory is a principal role of the OS.
    %\NVM
    %is broken up into pages, like DRAM. For coalescing related data, we define persistent
    %\emph{objects}, each of which is identified by a unique 128~bit object ID (though larger IDs would
    %be possible).
    Objects provide contiguous regions of memory that organize
    semantically related data with similar lifetime and permissions.
    Applications access objects via
    mapping services (discussed in the next section) by mapping each object into a contiguous range
    in the address space, though the address space itself may be densely or sparsely mapped.
    Objects can be anywhere from 4~KiB (the size of a page) to 1~GiB; the upper bound on object size is
    a prototype implementation choice, and not fundamental to the design.

    %TODO maybe move this elsewhere
    \Twizzler uses objects as the unit of access control, building off a
    read/write/execute permissions model which mirrors that of memory management units in modern
    processors. This is a direct consequence of avoiding the kernel for
    persistent data access---it can set policy by programming the MMU, but must leave enforcement up to
    the hardware which, in-turn, defines what protections are possible.

    %(it arises because of our persistent
    %pointer design, discussed later).
    An object, from the programmer's perspective, is flexible in its
    contents---for example, it could contain anywhere from a single B-tree node to the entire B-tree.
    Often, an object would contain the entire tree, since the entire tree is typically subject to
    the same access semantics by programs, and there are overheads associated with objects that can be
    amortized over larger spaces. Data and data structures that are too large for one object or require
    different access permissions can span multiple objects with references between them. We demonstrate
    the benefits of this flexibility in Section~\ref{sec:eval}.
}


\section{Object IDs}

\unedit{
    %% should this go in section 4.1/4.2?
    The advantage of a large object ID space is reduced coordination. A space of 128~bits does not
    require a centralized arbiter to hand out new IDs when creating objects. Instead, programs can
    allocate new objects through numerous methods. Currently, Twizzler allocates
    object IDs in a flat namespace using secure random numbers, which meets our needs in that the chance
    of collision is vanishingly small.
}

To ensure object ID uniqueness, we employ a probabilistic argument for avoiding collisions in the
object ID space. Since object IDs are generated randomly, we can model object IDs as an occupancy
problem in a space of $N = 2^{128}$ bins. Thus the probability of collision
is~\cite{motwani95}:

% TODO center equations
\begin{gather*}
    1 - e^{-
            \eqnmarkbox[NavyBlue]{m1}{m}
            (
            \eqnmarkbox[NavyBlue]{m2}{m}
            -1) / 2
            \eqnmarkbox[Orange]{n}{N}
        }
\end{gather*}
\annotatetwo[yshift=0.5em]{above}{m1}{m2}{\# of objects}
\annotate[yshift=-0.2em]{below}{n}{\# of object IDs}

If a system were to create millions of objects per second over the course of hundreds of years, the
probability of ID space collision is approximately 1 in $10^{-7}$. However, such a system is all but
guaranteed to suffer hardware errors that flip bits\sidenote{Take DRAM bit error from cosmic rays,
    for example.} in that time frame, and so an ID space collision is dramatically more likely to be
sourced from a hardware malfunction\sidenote{This is a common comparison when considering
    probability of a randomized computer process~\cite{hollingsworth:ssr97}.}. Further, the ID space
could be expanded to 256~bits, which would dramatically reduce the collision chances.

The reliance on randomized ID allocation is the primary reason we chose to make our object ID space
so much larger than some previous approaches~\cite{pmdk,pmdk-pointers}. Consider that if $N = 2^{64}$
bins, the probability of collision with just one billion objects is around 2\%. Increasing $m$ to
one object per person brings the collision probability up to nearly 75\%. Of course such an ID space
is usable if the ID are allocated via coordination with a centralized allocator, but if
we wish to allow object ID creation at scale, avoiding coordination is vital\sidenote{As we will
    discuss in the next chapter, some of these previous approches chose to put up with coordination and
    centralization because of the way they encoded their references. Twizzler uses a different method
    that allows ID space to be much larger.}.
