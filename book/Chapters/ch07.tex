
\chapter{Twizzler: An Implementation}\label{ch:twizzler}

\begin{chabstract}
    While the last two chapters have focused on perhaps the most important parts of Twizzler---global addressing, memory
    objects, and invariant pointers---there is still importance in understanding some of the other operating system
    services. This chapter will discuss things like ephemeral state management, controlling objects, threads, and security.
\end{chabstract}

An operating system provides many services to userspace all in service of enabling the application to operate on the
data it needs to by multiplexing the various pieces of hardware in the system. Twizzler is no different, however it
leans towards a lighter hand---more like a microkernel---than, \eg, \unix.

Twizzler is started via a bootloader that loads the kernel and an initial ramdisk (initrd) into memory. The initrd is a
simple tar file containing an initial set of memory objects to load. One of these is the init program, which is stared
by the kernel, and is the only executable that the kernel itself loads. After initializing the system, the kernel starts
the init program, which initialized the rest of userspace, including logging, paging, and devices, before starting a shell.

\section{Object Services}

The kernel provides services for object management, including creating and deleting objects. It maintains mapping
information, such as which objects are mapped into which address spaces, and common paging tasks like map counts and
usage statistics. If directly attached \NVM is present, the kernel manages direct mappings to \NVM via a built-in
mapping of object pages to \NVM pages. While not a filesystem, the kernel's use of \NVM does manage allocation and
mapping object pages to physical pages.

\subsection{Copy-From}

While it is possible for an application to just copy large amounts of data from one object to another via
\texttt{memcopy}\sidenote{Or a better language's equivalent routines.}, this is inefficient for large data. To provide
an efficient large-scale copy operation that takes advantage of copy-on-write functionality, Twizzler exposes a
copy-from system call. This system call takes, as arguments, a target object ID and a list of source specifications
which contain:

\begin{enumerate}
    \item \texttt{srcid}: A source object ID.
    \item \texttt{src\_start}: A starting byte offset, interpreted as an offset into the source object.
    \item \texttt{dst\_start}: A starting byte offset, interpreted as an offset into the target object.
    \item \texttt{length}: A length for the copy operation.
\end{enumerate}

The kernel then copies data from the source to the target. If it can, it makes use of full-page copies that require only
changing mappings (and, for persistent objects, stored object maps), and leverages copy-on-write. If a full-page cannot
by copied, the kernel does the byte-level copy on behalf of the thread. Before doing the copy, the kernel locks the
target object and the source objects to avoid unexpected changes (though, this behavior can be configured via flags).

\subsection{Creation}

Objects are created by the \texttt{create} system call, which
returns an object ID\@. The caller can specify two policy-level pieces of information about the object: its
\emph{lifetime} and its \emph{backing-type}. The lifetime may be either \emph{persistent} or \emph{volatile}, and the
backing type may be any type of physical memory available on the system (or a default). The kernel must adhere to the
semantics of persistence or volatility, but may choose any backing type it likes that implements the lifetime
requirements\sidenote{Even storing persistent objects in DRAM and flushing them to stable storage.}---the supplied
backing type is merely a hint. In addition to the policy information, the caller may supply a copy-from (see above) list
that will fill the new object with data before returning. If the list is empty, the created object contains all zeroed
memory, and any areas not covered by the copy-from list will be zeroed.
We will discuss in Chapter~\ref{ch:prog} more details on object lifetime and the safety hazards involved in object
creation.

\subsection{Deletion}

Objects may be be deleted via the \texttt{delete} system call.
Like \unix's \texttt{unlink}, objects are reference counted, where a reference refers to a mapping
in an address space. Once the reference count reaches zero, the object may be deleted. During
deletion, an object may be optionally marked as ``hidden'', causing new mapping requests for this
object to fail. We will discuss how application software can directly interact with these reference counts in Chapter~\ref{ch:prog}.

\subsection{External Paging}

If the kernel is unaware of a requested object or does not have a requested page in core, it will contact the userspace
paging service. The pager is started by init early on in the boot process and is allocated a special object to which it
shares read/write access with the kernel. This object is called the pager queue, and is used to form a multi-producer,
single-consumer queue submission/completion queue pair. The kernel can then communicate with the pager by enqueuing
requests and awaiting responses\sidenote{The pager also gets a ``pager to kernel'' communication pathway via a second
    queue pair.}. The pager can then handle paging requests and coordinate with the kernel on eviction. Drivers can be
handled in userspace in Twizzler, so storage device drivers can be implemented as part of the pager via shared libraries
for modularity.

\section{Dealing with Ephemera}

Despite \Twizzler's focus on persistent data, many components of our hardware and applications are
built around ephemeral constructs. For example, threads are ephemeral ``moments of computation''
that act on persistent data, while the programs that they execute often expect some ephemeral
private data (\eg the data segment and the stack). While virtual addresses are the wrong abstraction
for persistent data access, modern hardware provides (and often requires) the use of virtual address
hardware that we can leverage for protection and isolation, adding additional ephemeral state.

\subsection{Views}
\label{sec:view_impl}

\Twizzler defines objects called ``views'', which coalesce the state
and context necessary to support ephemeral constructs like threads and application instances into
\Twizzler objects. A significant part of that state is ephemeral virtual address mappings (discussed in Section~\ref{sec:view}); \Twizzler
provides access to persistent objects by mapping them into the virtual address space
behind-the-scenes (via \libcore). The view object contains structures to define the layout of the
virtual address space which the kernel reads and uses to program the MMU accordingly. Figure~\ref{fig:view2} shows how
views ``mesh'' ephemeral threads with persistent data by providing them a context to operate in.
Since view objects are normal \Twizzler objects, they can be persisted, allowing
us to recover application state after power cycles.

\begin{figure}
    \centering
    \includegraphics[width=4in]{fig/view2}
    \caption[View objects in Twizzler]{View objects in \Twizzler. Views manage ephemeral constructs and state, giving threads
        the necessary context to execute and access persistent data.}
    \label{fig:view2}
\end{figure}


By coalescing this ephemeral state
into an object, we make it possible for applications to manage it directly with minimal kernel
involvement. Avoiding the kernel is natural---all data access already does this in \Twizzler, so
adding a separate kernel API to manage this state would add complexity---and reduces the number of
system calls needed when mapping objects. Additionally, avoiding the kernel necessitates an
increased address space management responsibility for userspace. For example, executable loading
and mapping is largely handled without the kernel.

Applications can add objects to a view with the \texttt{view\_set} function. The caller specifies a
target object and a set of protections (see Chapter~\ref{ch:invariant}), and a slot in which to
map the object. However, applications rarely invoke this function directly---instead,
\texttt{libtwz} provides a higher-level API to allow applications to operate above the level of
manually mapping objects. The standard library also provides access to other utility functions for
views (such as querying state, creating new views, and copying views). These functions, by default,
operate on a thread's current view, but they may also optionally operate on any other view object,
which allows \Twizzler to implement operations with semantics similar to \texttt{fork} and \texttt{execve}.

When threads add entries to a view object they need not inform the kernel---when
a fault occurs, the kernel will read the entry as needed. However, when \emph{changing} or
\emph{deleting} an entry, threads must inform the kernel so it can update existing page table entries.
We provide two system calls for views. The \texttt{become} system call allows a thread to
change to a new view, which might be used to execute a new program or jump across programs to, for
example, accomplish a protected task. \Twizzler's access control system prevents this from happening
arbitrarily. The second system call is \texttt{invalidate\_view}, which lets a thread inform the
kernel of changed or deleted entries.

View objects not only reduce kernel boundary crossings, but they also improve the resumability of
the system. After a power cycle, the OS now has information on which objects were mapped and where,
improving the ability of threads to pick up where they left off. Additionally, view objects
facilitate the sharing of address spaces between threads, since they can both synchronize on
modifying a given view object and need not duplicate information. Note that the particular contents
of a view object are system-specific. On virtual memory systems, one of their jobs is to manage
ephemeral virtual mappings, while on other architectures their jobs may be to manage, \eg, segment
tables. However, in all cases, views provide a mechanism for managing ephemeral state while
providing enough context for threads to execute.

\subsection{Threads}

\Twizzler provides a set of threading primitives for applications. Threads in \Twizzler are always
attached to a view and one or more security contexts. Threads may communicate with each other using
shared memory and can signal each other with a system call.
Since everything in \Twizzler is an object, each thread has a state object associated
with it. Signals can be raised assuming the raiser has appropriate permissions on the state object,
and the state object contains information about the thread.

A key primitive in \Twizzler is the \texttt{thread-sync} system call. This call operates similar to
\texttt{futex(2)} on Linux, except that it supports waiting on and waking up a number of different
words of memory simultaneously. Multi-word thread-sync is necessary to support
\texttt{select(2)}-like or \texttt{poll(2)}-like operations in a system where all data access is
done with memory semantics. \Twizzler's standard library exposes an API for event handling that uses
multi-world thread-sync, where objects may expose a set of ``events'' that can be triggered and waited for. This is
used in numerous places to implement event handling for multiple communications streams implemented
in objects.

\subsection{Program Instancing}

Programs can be loaded and run as ELF objects specifically linked for Twizzler. We provide a linker script that links
program data into virtual addresses that correspond to the first few view slots in an address space. This way an ELF
file can be loaded as a simple copy-from operation from the ELF object into several new objects (\eg, a \texttt{text},
\texttt{rodata}, and \texttt{data} object). Program components like thread-local storage, stack, and heap can also be
created out of objects. Finally, Twizzler supports a \texttt{fork}-like operation that copies a view object into a new
view, remapping and applying copy-on-write copy-from operations as needed.

\section{Security}
\label{sec:sec}

\todo[inline]{Security section}
\unedit {
    A \textit{capability} is, at its core, an unforgeable token which
    grants a particular set of rights on an object~\cite{Lampson1973,Landwehr1981,Gong:sigops89}. A
    given capability must be protected from tampering, accessible only to a process which is authorized
    to have it, and obtainable only through some secure mechanism. Many of the systems discussed above
    use capabilities, albeit in different forms. Some are secure because they are stored in-kernel and
    accessed via indirection (\unix file descriptors), while some are password-based, granting access
    when the kernel matches the provided password against an ACL. In most cases, however, these systems
    require secure capability information to be stored, protected, in kernel-only memory. This limits
    the power of these systems and requires significant kernel involvement whenever a security decision
    is made.  Instead, \emph{signed} capabilities can be used~\cite{tanenbaum:osr81}, which allow the
    kernel to verify the contents of a capability without needing to call out to a secure service or
    trust that it has not been modified.
    This approach has obvious benefits for distributed systems and for systems with long-life persistent
    data, but has not seen significant research as an operating systems security concept over the past
    few decades.


}

\section{\textsc{unix} Compatibility}
\label{sec:legacy}

Twizzler provides a compatibility framework for POSIX applications. C applications link to a forked version of \texttt{musl}~\cite{musl}, a
C library written for Linux. We have modified \texttt{musl} to emit function calls to a library we wrote called
\texttt{Twix} instead of directly issuing system calls. The calls into \texttt{twix} are then handled by emulating their
Linux syscall behavior. For example, our implementation of \texttt{write(2)} allows us to create pseudo-terminal objects
that are shared between applications and a terminal emulator (that is hooked up to the serial port). Thus applications
can call \texttt{printf} to get their messages out to wider society. Rust applications do not need as much of a compatibility layer, both because we can modify
Rust's standard library more easily, and because Rust is not as tied to POSIX as C is.

\subsection{Porting to Twizzler}

In general, porting in \Twizzler is straight-forward. We have a collection of tools that provide a
framework for compiling software using the \Twizzler toolchain against other ported software and
libraries. Since we have chosen \texttt{musl} as our standard C library, many applications work
already with minor changes. However, it is often the case that applications require
some small tweaks to get running---for example, configuration paths---an experience common for anyone who has ported software to a new
operating system\sidenote{You can't see it, but I am raising my glass to you, those who have shared in this experience.}.

To date, we have ported a number of tools one would expect to find on a \unix system, such as
\texttt{busybox} (providing numerous command-line utilities), \texttt{bash}, \texttt{vim},
\texttt{gcc}, \texttt{binutils}, and others. Many of these programs required little or no
modification. Of course, this means that they do not gain some of the benefits \Twizzler's model
provides, since they still operate on persistent data with a POSIX model, however our goal in
porting these tools was not to improve their performance, it was to provide a somewhat familiar
environment for users.

Of course, perfect emulation of a Linux kernel is a huge effort, and it is not the primary goal of
our research. As a result, not all system calls are implemented and Linux features like
\texttt{procfs} are lacking. This means that some programs may require features that are not yet
implemented, and therefore require modifications to \texttt{twix} to run. However, as we continue to
port software, \texttt{twix}'s coverage of Linux features grows, making future porting easier. We
will continue to implement more support in \texttt{twix} for applications as needs arise. Note that
many applications (even complex applications like \texttt{gcc}) often boil down to reading and
writing files and managing processes, all of which is implemented.

\subsection{Twix System Call Overhead}

Our \unix emulation layer, \texttt{twix}, is meant to provide compatibility for legacy applications.
While we expect that applications will wish to take full advantage of \NVM and \Twizzler's
improvements in programmability and performance, we can still provide a small benefit
for applications that rely on \texttt{twix} to provide POSIX-like I/O. Access to \texttt{twix} is
done by \texttt{musl}, the C library we use, when it would normally perform a system call to a Linux
kernel. We replaced all instances of the \texttt{syscall} instruction in C and assembly code in
\texttt{musl} with a \texttt{call} instruction to an entry point in \texttt{twix}. This entry point,
despite being a function call, obeys the Linux system call ABI (\eg which registers hold
parameters). Thus while it has significantly less overhead than a full system call and context
switch, it does still have higher overhead than a normal function call since it must back up and
restore all registers.


\begin{SCtable}[b]
    \centering
    \caption[Emulated syscall latency]{Latency of selected \texttt{twix} system calls compared to Linux system calls.}
    \begin{minipage}{\linewidth}
        \centering
        \begin{tabular}{c | c | S[table-format=6.1]@{\,\,\( \pm \)\hspace{-7mm}} S[table-format=0.1]}
            \textbf{System Call} & \textbf{OS} & \multicolumn{2}{c}{\textbf{Average Latency (ns)}}       \\
            \hline
            \hline
            \texttt{getpid}      & Linux       & 98.7                                              & 2.3 \\
                                 & Twizzler    & 10.2                                              & 0.2 \\
            \hline
            \texttt{read}        & Linux       & 321.4                                             & 0.2 \\
                                 & Twizzler    & 55.4                                              & 0.2 \\
        \end{tabular}
    \end{minipage}
    \label{tbl:twix}
\end{SCtable}

Table~\ref{tbl:twix} shows the latency of some selected system calls on both Linux and \Twizzler
(implemented via \texttt{twix}). As expected, \texttt{getpid}'s overhead is small on both systems,
but on \Twizzler it is significantly lower. The difference, in this case, comes largely from the
kernel entry overhead. A small amount of additional overhead comes from
\texttt{twix} matching the Linux system call ABI and having to call its \texttt{getpid}
implementation through a lookup table.

We also measured the latency of a call to \texttt{read} for a file. We chose to do reads on cached
files for a small number of (already cached) bytes to avoid device transfer overhead. Performing a file read on
\Twizzler often amounts to a call to \texttt{memcpy}, so applications that perform large numbers of
small reads could see some benefit. In contrast, on Linux, the kernel needs to traverse internal
file structures, the page-cache, and possibly file system structures.
However, as we said, \texttt{twix} is intended for legacy
support, not performance improvement despite the lower system call overhead.
%As \texttt{read}
%lengths increase, we expect to see the system call overhead diminish relative to the cost of copying
%bytes into the buffer.

\begin{chconc}
    We now have an understanding of what addressing and pointers look like in Twizzler, and a basic idea of the
    operating system services Twizzler provides. One can write programs, multi-thread them and synchronize across
    threads and programs via object sync words, access, create, copy, and
    delete objects, and use \unix compatibility for things like \texttt{printf}. But this still doesn't address issues
    of memory safety, types, and failure-atomicity. Join us in the next chapter where we will start diving into these
    scary topics.
\end{chconc}